@page "/fetchdata"
@using AtCoderHeuristicDeck.Core
@inject HttpClient Http

<PageTitle>レーティング取得テスト</PageTitle>

<h1>レーティング取得テスト</h1>

@if (_statistics == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <p>@_statistics.UserName</p>
    <p>@_statistics.Rating</p>
    <table class="table">
        <thead>
            <tr>
                <th>perf</th>
                <th>contest</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var perf in _statistics.ExtendedPerformances.Performances)
            {
                <tr>
                    <td>@perf.Value</td>
                    <td>@perf.ContestName</td>
                </tr>
            }
        </tbody>
    </table>
    <p>
        <svg width="1000" height="1000">
            @foreach (var rect in _rectangles)
            {
                <rect x="@rect.X" y="@rect.Y" width="@rect.Width" height="@rect.Height" fill="@rect.Color.ToHexString()" stroke="black" stroke-width="0.5">
                    <title>@($"ExPerf: {rect.ExtendedPerf:0.00}\nRatio: {rect.Ratio * 100:0.00}%\nContestName: {rect.ContestName}")</title>
                </rect>
            }
        </svg>
    </p>
}

@code {
    private Statistics? _statistics;
    private Rectangle[] _rectangles;


    protected override async Task OnInitializedAsync()
    {
        _statistics = await Http.GetFromJsonAsync<Statistics>("api/user/terry_u16");
        _rectangles = CalcBestRectanbles(_statistics.ExtendedPerformances);
    }

    private Rectangle[] CalcBestRectanbles(ExtendedPerformanceList performances)
    {
        const int width = 1000;
        const int height = 1000;
        const int minHeight = 2;
        var weightedPerfs = performances.EnumeratePerformanceAndWeights().Select(pair => 
            {
                // 本当はこの寄与度は正しくないが、妥協
                var (perf, weight) = pair;
                return ToPositivePerf(perf.Value) * weight;
            }).ToArray();
        var totalPerfs = weightedPerfs.Sum();

        for (int i = 0; i < weightedPerfs.Length; i++)
        {
            weightedPerfs[i] *= width * height / totalPerfs;
        }

        var areaPrefixSum = new double[weightedPerfs.Length + 1];

        for (int i = 0; i < weightedPerfs.Length; i++)
        {
            areaPrefixSum[i + 1] = areaPrefixSum[i] + weightedPerfs[i];
        }

        var dp = new double[weightedPerfs.Length + 1];
        var from = new int[weightedPerfs.Length + 1];
        dp.AsSpan().Fill(double.MaxValue / 2);
        dp[0] = 0;

        for (int i = 0; i < weightedPerfs.Length; i++)
        {
            var nextAreaSum = 0.0;

            for (int j = i; j < weightedPerfs.Length; j++)
            {
                nextAreaSum += weightedPerfs[j];
                var currentHeight = nextAreaSum / width;
                var nextScore = dp[i];

                if (currentHeight < minHeight)
                {
                    continue;
                }

                // アスペクト比の重み付き調和平均っぽい何かを最小化したい
                for (int k = i; k <= j; k++)
                {
                    var currentWidth = weightedPerfs[k] / currentHeight;
                    var aspect = Math.Max(currentWidth / currentHeight, currentHeight / currentWidth);
                    nextScore += weightedPerfs[k] * aspect;
                }

                if (dp[j + 1] > nextScore)
                {
                    dp[j + 1] = nextScore;
                    from[j + 1] = i;
                }
            }
        }

        // 復元
        var ranges = new List<(int, int)>();
        var current = weightedPerfs.Length;

        while (current > 0)
        {
            var prev = from[current];
            ranges.Add((prev, current));
            current = prev;
        }

        ranges.Reverse();
        var rectangles = new Rectangle[weightedPerfs.Length];
        var heightPrefixSum = 0.0;

        foreach (var (prev, next) in ranges)
        {
            var currentAreaSum = 0.0;

            for (int i = prev; i < next; i++)
            {
                currentAreaSum += weightedPerfs[i];
            }

            var currentHeight = currentAreaSum / width;
            var x = 0.0;

            for (int i = prev; i < next; i++)
            {
                var dx = weightedPerfs[i] / currentHeight;
                var ratio = weightedPerfs[i] / (width * height);
                var contestName = performances.Performances[i].ContestName;
                var perf = performances.Performances[i].Value;
                var color = GetColor(ToPositivePerf(perf));
                rectangles[i] = new Rectangle(x, heightPrefixSum, dx, currentHeight, perf, ratio, contestName, color);
                x += dx;
            }

            heightPrefixSum += currentHeight;
        }

        return rectangles;
    }

    private double ToPositivePerf(double perf)
    {
        const int ratingThreshold = 400;

        if (perf >= 400)
        {
            return perf;
        }
        else
        {
            return ratingThreshold / Math.Exp((ratingThreshold - perf) / ratingThreshold);
        }
    }

    private Color GetColor(double perf)
    {
        if (perf >= 3200)
        {
            return new Color(0xff, 0x00, 0x00);
        }

        var floorPerf = (int)perf / 400 * 400;
        var ceilColor = perf switch
        {
            >= 2800 => new Color(0xff, 0x00, 0x00),
            >= 2400 => new Color(0xff, 0x80, 0x00),
            >= 2000 => new Color(0xc0, 0xc0, 0x00),
            >= 1600 => new Color(0x00, 0x00, 0xff),
            >= 1200 => new Color(0x00, 0xc0, 0xc0),
            >= 800 => new Color(0x00, 0x80, 0x00),
            >= 400 => new Color(0x80, 0x40, 0x00),
            _ => new Color(0x80, 0x80, 0x80)
        };

        var white = new Color(0xff, 0xff, 0xff);
        var alpha = (double)(perf - floorPerf) / 400 * 0.6 + 0.4;

        return ceilColor * alpha + white * (1 - alpha);
    }

    private readonly struct Color
    {
        private readonly double _r;
        private readonly double _g;
        private readonly double _b;

        public Color(byte r, byte g, byte b)
        {
            _r = (double)r / 255;
            _g = (double)g / 255;
            _b = (double)b / 255;
        }

        private Color(double r, double g, double b)
        {
            _r = r;
            _g = g;
            _b = b;
        }

        public static Color operator *(Color c, double v)
        {
            return new Color(c._r * v, c._g * v, c._b * v);
        }

        public static Color operator +(Color c1, Color c2)
        {
            return new Color(c1._r + c2._r, c1._g + c2._g, c1._b + c2._b);
        }

        public string ToHexString()
        {
            var r = Math.Clamp((int)Math.Round(_r * 255), 0x00, 0xff);
            var g = Math.Clamp((int)Math.Round(_g * 255), 0x00, 0xff);
            var b = Math.Clamp((int)Math.Round(_b * 255), 0x00, 0xff);
            return $"#{r.ToString("x2")}{g.ToString("x2")}{b.ToString("x2")}";
        }
    }

    private record Rectangle(double X, double Y, double Width, double Height, double ExtendedPerf, double Ratio, string ContestName, Color Color);
}
